--------------------Introduction and Lists -------------------------------------

Container Sequences - Hold other types of data
Sepcific container sequences -inc lists, dictionarys, tuples

Lists -
  Hold data in order it was added
  Mutable
  Index to acccess a specific element
  
  
  Ex: List
                  cookies = ['chocolate chip', 'peanut butter', 'oatmeal', 'sugar']
                  coookies.append('Tirggel')       #add new items to lists using the append method
                  print(cookies)
                  print(cookies[2])
                  
                  
 Combining lists
        Can either use operator or .extend() - merges a list into another list at the end
        
        Operator method (1):
        
                  cakes = ['strawberry', 'vanilla']
                  desserts = cookies + cakes
                  print(desserts)
                  
        Extends Method (2):

Find and Remove Elements in a List 
        .index() method locates the position of a data element in a list
        
                  position = cookies.index('sugar')
                  print(position)
                  cookies[3]
        
        
        .pop() method removes an item from a list and allow you to save it
        
                  name = cookies.pop(position)
                  print(name)
                  print(cookies)

 Iterating and sorting over a list
      for loops are the most common way of iterating over a list
 
                  for cookie in cookies :
                        print(cookie)
                        
      sorted() function sorts data in numerical or alpjabetical order and returns a new list 
      
                  print(cookies)
                  sorted_cookies = sorted(cookies)
                  
                  
  .extend() - allows youto combine a list with another array type (list, set, tuple)
  .append() - adding individual data elements to a list by using the .append() method
  
                  >>>>>>>>>>>>>> Code SNippet: Manipulating lists
                                          # Create a list containing the names: baby_names
                                          baby_names = ['Ximena', 'Aliza', 'Ayden', 'Calvin']

                                          # Extend baby_names with 'Rowen' and 'Sandeep'
                                          baby_names.extend(['Rowen','Sandeep'])

                                          # Print baby_names
                                          print(baby_names)

                                          # Find the position of 'Aliza': position
                                          position = baby_names.index('Aliza')

                                          # Remove 'Aliza' from baby_names
                                          baby_names.pop(position)

                                          # Print baby_names
                                          print(baby_names)
                                          
                                          


                     >>>>>>>>>>>>>>>>> Code SNippet: Looping over lists 
                                     # Create the empty list: baby_names
                                          baby_names = []

                                          # Loop over records 
                                          for row in records:
                                              # Add the name to the list
                                              baby_names.append(row[3])

                                          # Sort the names in alphabetical order
                                          for name in sorted(baby_names):
                                              # Print each name
                                              print(name)
         





---------------------------------- Meet the tuples---------------------------------
Tuples - like lists
    Holds data in order
    Can access individual elements inside a tuple with index
    
    Easier to process and more efficient
    Immutable - can ensure data isn't altered
    Can create tuples by pairing up elements
    Can use tuple unpacking to expand a tuple into named variables that represent each element in the tuple
    
    
Zipping and Unpacking    
        tuples are commonly created by zipping lists together with zip()
        Two lists: us_ookies ,  in_cookies
        
                                      top_pairs = zip(us_cookies, in_cookies)
                                      print(top_pairs)
                                      
         tuple unpacking is a very exporessive way for working with data
            -allows us to assign the elements of a tuple to named variables for later use
            -syntax allows us to create more readable and less error prone code
            
            start by putting both variables as the target of the assignment statement separated by a comma
            Then assign the first tuple in our top pairs list to them
                                     us_num_1, in_num_1 = top_pairs[0]   
            
         
        More unpacking in Loops
                Can use tuple unpacking to separate a list of tuples into their elements as we loop over them
                

                                        for us_cookie, in_cookie in top_pairs:
                                                    print(in_cookie)
                                                    print(us_cookie)

          Enumerating Positions        
                  Another use of tuple unpacking helps us keep track of which element in the iterable or list we are currently on 
                  Often we want to know what the index is of an element in the iterable is. The enumerate function enabled us to do that by creating tuples where the first element of the tuple is the index of the element in the original list, then the element itself. 
                  We can use this to track rankings in our data or skip elements we are not interested in. 
                  Here I'm going to enumerate our top pairs list and split that resulting tuple into index and item. 
                  I can also use tuple unpacking on the item to get all three components separately. 
                  This can be exceptionally powerful. 
                  
                          - Another useful tuple creation method is the eunmerate() function
                          Enumeration is used in loops to return the postion and the data in that position while looping
                          
                                                    for idx, item in enumerate(top_pairs) :
                                                            us_cookie, in_cookie = items
                                                            print(idx, us_cookie, in_cookie)
                                                            
                  BE careful when making tuples!
                      Can use different methods like zip(), enumerate() or () t make tuples
                                  
                                                    items = ('vanilla', 'chocolate')
                                  
                   But beware of trailing commas!
                   
                                                       item2 = 'butter',
                                                            
                                                            
                                                            
    Using and unpacking tuples
Tuples are made of several items just like a list, but they cannot be modified in any way. It is very common for tuples to be used to represent data from a database. If you have a tuple like ('chocolate chip cookies', 15) and you want to access each part of the data, you can use an index just like a list. However, you can also "unpack" the tuple into multiple variables such as type, count = ('chocolate chip cookies', 15) that will set type to 'chocolate chip cookies' and count to 15.

Often you'll want to pair up multiple array data types. The zip() function does just that. It will return a list of tuples containing one element from each list passed into zip().

When looping over a list, you can also track your position in the list by using the enumerate() function. The function returns the index of the list item you are currently on in the list and the list item itself.

You'll practice using the enumerate() and zip() functions in this exercise, in which your job is to pair up the most common boy and girl names.                                                         
     
     
     
     
     
     
     >>>>>>>>>>>>>>> Code SNippet: Using and Unpacking Tuples:
                                         # Pair up the boy and girl names: pairs
                                          pairs = zip(girl_names, boy_names)

                                          # Iterate over pairs
                                          for idx, pair in enumerate(pairs):
                                              # Unpack pair: girl_name, boy_name
                                              girl_name, boy_name = pair      #### this is similar to naming the components of the tuple
                                              # Print the rank and names associated with each rank
                                              print('Rank {}: {} and {}'.format(idx, girl_name, boy_name))

                       
                                    
   >>>>>>>>>>>>>>>>>>>>> Code Snippet: Making Tuples by Accident:
                                       # Create the normal variable: normal
                            normal = 'simple'

                            # Create the mistaken variable: error
                            error = 'trailing comma',

                            # Print the types of the variables
                            print(type(normal))
                            print(type(error))                   
       
       
       
       
       
  --------------------------------Sets for unordered and unique data ------------------------------------     
       
       Sets - 
          Excellent for finding all the unique values in a column of your data, a list of elements, or even rows from a file.
          We use sets when we want to store unique data elements in an unordered fashion.
          Sets are mutable, so can add and remove elements from them. 
          Just going to scratch surface of what can be done with sets. Has many more capabilities that align wuth set theory from math. 
          
          
       
       Creating Sets
                -Sets are created from a list. 
                
                                cookies_eated_today =['choclate chip', 'peanut butter', 'chocolate chip', 'oatmeal cream', 'chocolate chip']
                                types_of_cookies_eaten = set(cookies_eaten_today)
                                print(types_of_cookies_eaten)
                                
                                
        Modifying a Set
                  .add() - adds single elements; will only add the element if it is unique, otherwise it just continues on -When working with a set, will use the add method to add a new element to the set
                  
                  .update() - merges in another set or list; can add multiple items using the update method; update method takes a list of items and adds each one to the set if it is not present
                  
                
                                            types_of_cookies_eaten.add('biscotti')
                                            types_of_cookies_eaten.add('chocolate chip')
                                            print(types_of_cookies_eaten)
                                            
                                            cookies_hugo_ate = ['chocolate chip','anzac']
                                            types_of_cookies_eaten.update(cookies_hugo_ate)
                                            print(types_of_cookies_eaten_
                                            
            Removing data from sets
                      .discard() - safely removes an element from the sey by its value - No error will be thrown if the data isn't found - When removing data from a set, we can use the discard method to safely remove an element from the set by its vlaue
                      
                      .pop()  - Can also use the pop method to remove and return an arbitrary element from the set (KeyError when empty) 
                      
                          
                          
                                          types_of_cookies_eaten.discard('biscotti')
                                          print(types_of_cookies_eaten)
                                            
                                            
                                            
             Set Operations - Similarities
                      .union()  - set method returns a set of all the names (or)
                      .intersection() - method identifies overlapping data (and) 
             
                      
                      
                                                     cookies_jason_ate = set(['chocolate chip', 'oatmeal cookie', 'peanut butter'])
                                                     
                                                     cookies_hugo_ate = set (['chocolate chip', 'anzac'])
                                                     
                                                     cookies_jason_ate.union(cookies_hugo_ate)
                                                     cookies_jason_ate.intersection(cookies_hugo_ate)
                                                     
                        .difference()   - method identifies data present in the set on which the method was used that is not in the arguments (-). The target we call the difference method on is important as that will be the basis for our differences. 
                        
                                                      cookies_jason_ate.difference(cookies_hugo_ate)    ### See the cookies that Jason ate that Hugo didn't
                                                      
                                                      cookies_hugo_ate.difference(cookies_jason_ate)    ### see the cookies that hugo ate and jason ddin't
                                                      
                                                      
                                                      
                                        >>>>>>>>>>>>>>> Finding all the data and the overlapping data between sets
                                                        Code Snippet: # Find the union: all_names
                                                                        all_names = baby_names_2011.union(baby_names_2014)

                                                                        # Print the count of names in all_names
                                                                        print(len(all_names))

                                                                        # Find the intersection: overlapping_names
                                                                        overlapping_names = baby_names_2011.intersection(baby_names_2014)

                                                                        # Print the count of names in overlapping_names
                                                                        print(len(overlapping_names))

                                         >>>>>>>>>>>>>>>>>> Determining set differences
                                                            Code Snippet: # Create the empty set: baby_names_2011
                                                                            baby_names_2011 = set()

                                                                            # Loop over records and add the names from 2011 to the baby_names_2011 set
                                                                            for row in records:
                                                                                # Check if the first column is '2011'
                                                                                if row[0] == '2011':
                                                                                    # Add the fourth column to the set
                                                                                    baby_names_2011.add(row[3])

                                                                            # Find the difference between 2011 and 2014: differences
                                                                            differences = baby_names_2011.difference(baby_names_2014)

                                                                            # Print the differences
                                                                            print(differences)
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
--------------------------------------Using Dictionaries----------------------------------------------
Dictionaries are useful for storing key/value pairs, grouping data by time or structuring hierarchical data like org charts.

                                                        
Creating and Looping through dictionaries
            -Hold data in key/value pairs - while they key must be alphanumeric, the value can be any other data type
            -Nestable - Use a dictionary as the value of a key within a dictionary - also possible to nest dictionaries so that you can work with grouped or hierarchical data
            -Iterable - We can also iterate over the keys and values of a dictionary
                       -We can also iterate over the items of a dictionary, which are tuples of the key value pairs!
            -Create dictionaries using the dict() or the braces method {}           

             
             
          -Have list of tuples in this example to turn into a dictionary, so can quickly find the zipcode without having to scan the whole list
          
                                    art_galleries = {}                   ###Created empty dictionary
                                    
                                    for name, zip_code in galleries :                ##### use tuple unpacking as loop over the galleries list that contains data
                                              art_galleries[name] = zip_code         ###### Inside the loop, set the name of the gallery as the key in my dictionary and the zip code as the value
                                              
                                              
                                    for name in art_galleries :                 ########### Finally want to fund the last 5 art gallery names
                                               print(name)
                                  
  
                                                        
                        By default, when using sorted on a dictionary or looping over a dictionary we loop over the keys, so will print the keys by name.
                        
                        Accessing dictionary vale=ues by key -- 
                               
                               Safely finding by key -- getting a value from a dictionary is done by using the key as an index;
                                                             however, if the key isn't present you will get an ugly exception that stops the execution of your code (KeyError)
                                                    While you could use Python exception hadling, this is so common that dictionaries have a get() method just for this problem
                                         .get() method allows you to safely access a key without errir or exception handling (allows you to safely get a value from a key by passing the key)
                                                         -if a key is not in the dictionary, .get() returns None by default or you can supply a value to return
                                                                    -you can optionally supply a second argument which will be returned instead of None
                                                             
                                        ex:
                                        
                                                    art_galleries.get('Louvre','Not Found')                
                                           If you do supply a valid key to the get() method it will return the value from the dictionary 
                                            
         
         -WQorking with nested data
                    -Can also nest dictionaries to group data or establish hierarchy 
                                .keys() method shows the keys for a given dictionary
                                
                                
                                                  art_galleries.keys()
                                                  dict_keys(['10021','10013','10001','10011'])
                                                  
                                                  print(art_galleries['10027'])
                                                  art_galleries['10027']['Inner City Art Ga;;ery Inc']  ##Getting the phone number of one of the galleries by using the gallery name which us the nested dictionary's key aas a secondary key
                                                  
                     -Nesting dictionaries is a very commom way to deal with repeating data structures such as yearly data, grouped, or hierarchical data such as organization reporting structures
                     -You can access nested values by providing multiple indices to the dictionary or using the get mothod on AN INDEX
                     
                                          -Can be accessed using multiple indices or the .get() method on an index
                                                  
         
         
         >>>>>>>>>>>>>>>>>> Code snippet: Creatijg and looping through dictionaries
                                     # Create an empty dictionary: names
                            names = {}

                            # Loop over the girl names
                            for name, rank in female_baby_names_2012:
                                # Add each name to the names dictionary using rank as the key
                                names[rank] = name

                            # Sort the names list by rank in descending order and slice the first 10 items
                            for rank in sorted(names,reverse=True)[:10]:
                                # Print each item
                                print(names[rank])


          >>>>>>>>>>>>>Code Snippet: Safely Finding by Key
          As demonstrated in the video, if you attempt to access a key that isn't present in a dictionary, you'll get a KeyError. One option to handle this type of error is to use a try: except: block. You can learn more about error handling in Python Data Science Toolbox (Part 1), specifically in this video.

Python provides a faster, more versatile tool to help with this problem in the form of the .get() method. The .get() method allows you to supply the name of a key, and optionally, what you'd like to have returned if the key is not found.
                             
                             
                             # Safely print rank 7 from the names dictionary
                                print(names.get(7))

                                # Safely print the type of rank 100 from the names dictionary
                                print(type(names.get(100)))

                                # Safely print rank 105 from the names dictionary or 'Not Found'
                                print(names.get(105,'Not Found'))








                  >>>>>>>>>>>>>Code Snippet: Dealing with Nested Data 


                                          # Print a list of keys from the boy_names dictionary
                      print(boy_names.keys())

                      # Print a list of keys from the boy_names dictionary for the year 2013
                      print(boy_names[2013].keys())

                      # Loop over the dictionary
                      for year in boy_names:
                          # Safely print the year and the third ranked name or 'Unknown'
                          print(year, boy_names[year].get(3,'Unknown'))   

         
         
         
  ----------------------------------Altering Dictionaries___________________________________________________
Dictionaries are mutable, so we can alter them in  number of ways
Adding and Extending Dictionaries
            - Assignment to add a new key/value to a dictionary
                              -You can add data to a dictionary just by using a new key as an index and assigning it a value 
                              -Also possible to supply a dictionary, list of tuples or a set of keywords arguments to the update()  method to add values into a dictionary
                                                  - .update() method to updaTE A DICTIONARY FROM ANOTHER DICTIONARY OR TUPLES OR KEYWORDS
                                                  
                              
                              
                              print(galleries_10007)    ### Have zipcode want to add
                              art_galleries['10007'] = galleries_10007    ### Assign zipcode as the key and then the dictionary as the value
                              
                              galleries_11234 = [("A J ARTS LTD', '(718) 763-5473'), ('Doug Meyer Fine Art", '(718) 375-8006')]   #### Can also create a list of tuples and supply them to the update() method
                              art_galleries['11234'].update(galleries_11234)   ### Supplying them to a dictionary index of the ziupcode since I want this data to be neted underneath it
                              
                              print(art_galleries['11234'])   ###Print the zipcode to be sure they wered added
            
         
         -Often we'll want to narrow the data to only the data which is relevant to the problem at hand, so let's lear how to remove data

Popping and deleting from dictionaries         
               - del instruction deletes a key?value  - however its important to remember that del will throw a KeyError if the key tyou're trying to delete doesn't exist
               - .pop() method safely removes a key/value froma dictionary 
         
                            - del art_galleries['11234']     ###let's start by removing all the galleries from zipcode '11234'
                            
                            galleries_10310 = art_galleries.pop('10310')        ### Not sure if there are any galleries in zipcode 10310, so I'm going to pop that zip code from the dictionary and save it
                            
                            
        Adding and extending dictionaries
If you have a dictionary and you want to add data to it, you can simply create a new key and assign the data you desire to it. It's important to remember that if it's a nested dictionary, then all the keys in the data path must exist, and each key in the path must be assigned individually.

You can also use the .update() method to update a dictionary with keys and values from another dictionary, tuples or keyword arguments. 
         
         
         
         
         
         
         >>>>>>>>>>>>>>>>> Code Snippet: Adding and Extending Dictionaries
         # Assign the names_2011 dictionary as the value to the 2011 key of boy_names
boy_names[2011] = names_2011

# Update the 2012 key in the boy_names dictionary
boy_names[2012].update(((1,'Casey'),(2,'Aiden')))

# Loop over the boy_names dictionary 
for year in boy_names:
    # Loop over and sort the data for each year by descending rank
    for rank in sorted(boy_names[year], reverse=True)[:1]:
        # Check that you have a rank
        if not rank:
            print(year, 'No Data Available')
        # Safely print the year and the least popular name or 'Not Available'
        print(year, boy_names[year].get(rank))
        
        
        
        Popping and deleting from dictionaries
Often, you will want to remove keys and value from a dictionary. You can do so using the del Python instruction. It's important to remember that del will throw a KeyError if the key you are trying to delete does not exist. You can not use it with the .get() method to safely delete items; however, it can be used with try: catch:.

If you want to save that deleted data into another variable for further processing, the .pop() dictionary method will do just that. You can supply a default value for .pop() much like you did for .get() to safely deal with missing keys. It's also typical to use .pop() instead of del since it is a safe method.

Here, you'll remove 2011 and 2015

>>>>>>>>>>>>>>>>>>Code Snippet
# Remove 2011 and store it: female_names_2011
female_names_2011 = female_names.pop(2011)

# Safely remove 2015 with an empty dictionary as the default: female_names_2015
female_names_2015 = female_names.pop(2015,{})

# Delete 2012
del female_names[2012]

# Print female_names
print(female_names)



        
        
-----------------------------------------------------Pythonically Using Dictionaries________________________________
 Previously we looped through dictionary keyts then used the keys to get the values we desired
 
          -   .items() method returns an object we can iterate over  ---   Python provides an items() method which returns a dict_items pobject but we can iterate over it as a list of key/value tuples
          
 If we use the .items()  metho on the original art_galleries dictionary it returns a tuple of the gallery name and then the phone number
        
         for gallery, phone_num in art_galleries.items():
                print(gallery)
                print(phone_num)
                
                
  I can use tuple unpacking to go ahead and expand that into its two components in the loop      
  Finally, I print them so you can see the information. 
  
  Now a more pythonic method for checking if the data is present in a dictionary 
  
  Checking Dictionairies for Data
            - earlier we ued the .get() method to safely check for keys and we can use that to check to see if a key is in a dictionary
            -python provides the in operator (which is much more efficient and clear) -- returns a boolean (True or False) 
                                                    -since returns a boolean, it is often used in conditionals statements like an if/else statement
  
  
                          '11234' in art_galleries        #Checks to see if key '11234' is in galleries
                          
                          
                          if '10010' in art_galleries : 
                                  print('I found: %s' % art_galleries['10010'])
                          else:
                                  print('No galleries found')
                          
     Working with dictionaries more pythonically
So far, you've worked a lot with the keys of a dictionary to access data, but in Python, the prefered manner for iterating over items in a dictionary is with the .items() method.

This returns each key and value from the dictionary as a tuple, which you can unpack in a for loop. You'll now get practice doing this.                     
         
         
         
         
         
         
         
         
         
                
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
       
                  
                  
                                         
  
  
  














