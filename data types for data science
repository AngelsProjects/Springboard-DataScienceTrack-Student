--------------------Introduction and Lists -------------------------------------

Container Sequences - Hold other types of data
Sepcific container sequences -inc lists, dictionarys, tuples

Lists -
  Hold data in order it was added
  Mutable
  Index to acccess a specific element
  
  
  Ex: List
                  cookies = ['chocolate chip', 'peanut butter', 'oatmeal', 'sugar']
                  coookies.append('Tirggel')       #add new items to lists using the append method
                  print(cookies)
                  print(cookies[2])
                  
                  
 Combining lists
        Can either use operator or .extend() - merges a list into another list at the end
        
        Operator method (1):
        
                  cakes = ['strawberry', 'vanilla']
                  desserts = cookies + cakes
                  print(desserts)
                  
        Extends Method (2):

Find and Remove Elements in a List 
        .index() method locates the position of a data element in a list
        
                  position = cookies.index('sugar')
                  print(position)
                  cookies[3]
        
        
        .pop() method removes an item from a list and allow you to save it
        
                  name = cookies.pop(position)
                  print(name)
                  print(cookies)

 Iterating and sorting over a list
      for loops are the most common way of iterating over a list
 
                  for cookie in cookies :
                        print(cookie)
                        
      sorted() function sorts data in numerical or alpjabetical order and returns a new list 
      
                  print(cookies)
                  sorted_cookies = sorted(cookies)
                  
                  
  .extend() - allows youto combine a list with another array type (list, set, tuple)
  .append() - adding individual data elements to a list by using the .append() method
  
                  >>>>>>>>>>>>>> Code SNippet: Manipulating lists
                                          # Create a list containing the names: baby_names
                                          baby_names = ['Ximena', 'Aliza', 'Ayden', 'Calvin']

                                          # Extend baby_names with 'Rowen' and 'Sandeep'
                                          baby_names.extend(['Rowen','Sandeep'])

                                          # Print baby_names
                                          print(baby_names)

                                          # Find the position of 'Aliza': position
                                          position = baby_names.index('Aliza')

                                          # Remove 'Aliza' from baby_names
                                          baby_names.pop(position)

                                          # Print baby_names
                                          print(baby_names)
                                          
                                          


                     >>>>>>>>>>>>>>>>> Code SNippet: Looping over lists 
                                     # Create the empty list: baby_names
                                          baby_names = []

                                          # Loop over records 
                                          for row in records:
                                              # Add the name to the list
                                              baby_names.append(row[3])

                                          # Sort the names in alphabetical order
                                          for name in sorted(baby_names):
                                              # Print each name
                                              print(name)
         





---------------------------------- Meet the tuples---------------------------------
Tuples - like lists
    Holds data in order
    Can access individual elements inside a tuple with index
    
    Easier to process and more efficient
    Immutable - can ensure data isn't altered
    Can create tuples by pairing up elements
    Can use tuple unpacking to expand a tuple into named variables that represent each element in the tuple
    
    
Zipping and Unpacking    
        tuples are commonly created by zipping lists together with zip()
        Two lists: us_ookies ,  in_cookies
        
                                      top_pairs = zip(us_cookies, in_cookies)
                                      print(top_pairs)
                                      
         tuple unpacking is a very exporessive way for working with data
            -allows us to assign the elements of a tuple to named variables for later use
            -syntax allows us to create more readable and less error prone code
            
            start by putting both variables as the target of the assignment statement separated by a comma
            Then assign the first tuple in our top pairs list to them
                                     us_num_1, in_num_1 = top_pairs[0]   
            
         
        More unpacking in Loops
                Can use tuple unpacking to separate a list of tuples into their elements as we loop over them
                

                                        for us_cookie, in_cookie in top_pairs:
                                                    print(in_cookie)
                                                    print(us_cookie)

          Enumerating Positions        
                  Another use of tuple unpacking helps us keep track of which element in the iterable or list we are currently on 
                  Often we want to know what the index is of an element in the iterable is. The enumerate function enabled us to do that by creating tuples where the first element of the tuple is the index of the element in the original list, then the element itself. 
                  We can use this to track rankings in our data or skip elements we are not interested in. 
                  Here I'm going to enumerate our top pairs list and split that resulting tuple into index and item. 
                  I can also use tuple unpacking on the item to get all three components separately. 
                  This can be exceptionally powerful. 
                  
                          - Another useful tuple creation method is the eunmerate() function
                          Enumeration is used in loops to return the postion and the data in that position while looping
                          
                                                    for idx, item in enumerate(top_pairs) :
                                                            us_cookie, in_cookie = items
                                                            print(idx, us_cookie, in_cookie)
                                                            
                  BE careful when making tuples!
                      Can use different methods like zip(), enumerate() or () t make tuples
                                  
                                                    items = ('vanilla', 'chocolate')
                                  
                   But beware of trailing commas!
                   
                                                       item2 = 'butter',
                                                            
                                                            
                                                            
    Using and unpacking tuples
Tuples are made of several items just like a list, but they cannot be modified in any way. It is very common for tuples to be used to represent data from a database. If you have a tuple like ('chocolate chip cookies', 15) and you want to access each part of the data, you can use an index just like a list. However, you can also "unpack" the tuple into multiple variables such as type, count = ('chocolate chip cookies', 15) that will set type to 'chocolate chip cookies' and count to 15.

Often you'll want to pair up multiple array data types. The zip() function does just that. It will return a list of tuples containing one element from each list passed into zip().

When looping over a list, you can also track your position in the list by using the enumerate() function. The function returns the index of the list item you are currently on in the list and the list item itself.

You'll practice using the enumerate() and zip() functions in this exercise, in which your job is to pair up the most common boy and girl names.                                                         
     
     
     
     
     
     
     >>>>>>>>>>>>>>> Code SNippet: Using and Unpacking Tuples:
                                         # Pair up the boy and girl names: pairs
                                          pairs = zip(girl_names, boy_names)

                                          # Iterate over pairs
                                          for idx, pair in enumerate(pairs):
                                              # Unpack pair: girl_name, boy_name
                                              girl_name, boy_name = pair      #### this is similar to naming the components of the tuple
                                              # Print the rank and names associated with each rank
                                              print('Rank {}: {} and {}'.format(idx, girl_name, boy_name))

                       
                                    
   >>>>>>>>>>>>>>>>>>>>> Code Snippet: Making Tuples by Accident:
                                       # Create the normal variable: normal
                            normal = 'simple'

                            # Create the mistaken variable: error
                            error = 'trailing comma',

                            # Print the types of the variables
                            print(type(normal))
                            print(type(error))                   
       
       
       
       
       
  --------------------------------Sets for unordered and unique data ------------------------------------     
       
       Sets - 
          Excellent for finding all the unique values in a column of your data, a list of elements, or even rows from a file.
          We use sets when we want to store unique data elements in an unordered fashion.
          Sets are mutable, so can add and remove elements from them. 
          Just going to scratch surface of what can be done with sets. Has many more capabilities that align wuth set theory from math. 
          
          
       
       Creating Sets
                -Sets are created from a list. 
                
                                cookies_eated_today =['choclate chip', 'peanut butter', 'chocolate chip', 'oatmeal cream', 'chocolate chip']
                                types_of_cookies_eaten = set(cookies_eaten_today)
                                print(types_of_cookies_eaten)
                                
                                
        Modifying a Set
                  .add() - adds single elements; will only add the element if it is unique, otherwise it just continues on -When working with a set, will use the add method to add a new element to the set
                  
                  .update() - merges in another set or list; can add multiple items using the update method; update method takes a list of items and adds each one to the set if it is not present
                  
                
                                            types_of_cookies_eaten.add('biscotti')
                                            types_of_cookies_eaten.add('chocolate chip')
                                            print(types_of_cookies_eaten)
                                            
                                            cookies_hugo_ate = ['chocolate chip','anzac']
                                            types_of_cookies_eaten.update(cookies_hugo_ate)
                                            print(types_of_cookies_eaten_
                                            
            Removing data from sets
                      .discard() - safely removes an element from the sey by its value - No error will be thrown if the data isn't found - When removing data from a set, we can use the discard method to safely remove an element from the set by its vlaue
                      
                      .pop()  - Can also use the pop method to remove and return an arbitrary element from the set (KeyError when empty) 
                      
                          
                          
                                          types_of_cookies_eaten.discard('biscotti')
                                          print(types_of_cookies_eaten)
                                            
                                            
                                            
             Set Operations - Similarities
                      .union()  - set method returns a set of all the names (or)
                      .intersection() - method identifies overlapping data (and) 
             
                      
                      
                                                     cookies_jason_ate = set(['chocolate chip', 'oatmeal cookie', 'peanut butter'])
                                                     
                                                     cookies_hugo_ate = set (['chocolate chip', 'anzac'])
                                                     
                                                     cookies_jason_ate.union(cookies_hugo_ate)
                                                     cookies_jason_ate.intersection(cookies_hugo_ate)
                                                     
                        .difference()   - method identifies data present in the set on which the method was used that is not in the arguments (-). The target we call the difference method on is important as that will be the basis for our differences. 
                        
                                                      cookies_jason_ate.difference(cookies_hugo_ate)    ### See the cookies that Jason ate that Hugo didn't
                                                      
                                                      cookies_hugo_ate.difference(cookies_jason_ate)    ### see the cookies that hugo ate and jason ddin't
                                                      
                                                      
                                                      
                                        >>>>>>>>>>>>>>> Finding all the data and the overlapping data between sets
                                                        Code Snippet: # Find the union: all_names
                                                                        all_names = baby_names_2011.union(baby_names_2014)

                                                                        # Print the count of names in all_names
                                                                        print(len(all_names))

                                                                        # Find the intersection: overlapping_names
                                                                        overlapping_names = baby_names_2011.intersection(baby_names_2014)

                                                                        # Print the count of names in overlapping_names
                                                                        print(len(overlapping_names))

                                         >>>>>>>>>>>>>>>>>> Determining set differences
                                                            Code Snippet: # Create the empty set: baby_names_2011
                                                                            baby_names_2011 = set()

                                                                            # Loop over records and add the names from 2011 to the baby_names_2011 set
                                                                            for row in records:
                                                                                # Check if the first column is '2011'
                                                                                if row[0] == '2011':
                                                                                    # Add the fourth column to the set
                                                                                    baby_names_2011.add(row[3])

                                                                            # Find the difference between 2011 and 2014: differences
                                                                            differences = baby_names_2011.difference(baby_names_2014)

                                                                            # Print the differences
                                                                            print(differences)
                                                                            
                                                                            
                                                                            
                                                                            
                                                                            
--------------------------------------Using Dictionaries----------------------------------------------
Dictionaries are useful for storing key/value pairs, grouping data by time or structuring hierarchical data like org charts.

                                                        
Creating and Looping through dictionaries
            -Hold data in key/value pairs - while they key must be alphanumeric, the value can be any other data type
            -Nestable - Use a dictionary as the value of a key within a dictionary - also possible to nest dictionaries so that you can work with grouped or hierarchical data
            -Iterable - We can also iterate over the keys and values of a dictionary
                       -We can also iterate over the items of a dictionary, which are tuples of the key value pairs!
            -Create dictionaries using the dict() or the braces method {}           

             
             
          -Have list of tuples in this example to turn into a dictionary, so can quickly find the zipcode without having to scan the whole list
          
                                    art_galleries = {}                   ###Created empty dictionary
                                    
                                    for name, zip_code in galleries :                ##### use tuple unpacking as loop over the galleries list that contains data
                                              art_galleries[name] = zip_code         ###### Inside the loop, set the name of the gallery as the key in my dictionary and the zip code as the value
                                              
                                              
                                    for name in art_galleries :                 ########### Finally want to fund the last 5 art gallery names
                                               print(name)
                                  
  
                                                        
                        By default, when using sorted on a dictionary or looping over a dictionary we loop over the keys, so will print the keys by name.
                        
                        Accessing dictionary vale=ues by key -- 
                               
                               Safely finding by key -- getting a value from a dictionary is done by using the key as an index;
                                                             however, if the key isn't present you will get an ugly exception that stops the execution of your code (KeyError)
                                                    While you could use Python exception hadling, this is so common that dictionaries have a get() method just for this problem
                                         .get() method allows you to safely access a key without errir or exception handling (allows you to safely get a value from a key by passing the key)
                                                         -if a key is not in the dictionary, .get() returns None by default or you can supply a value to return
                                                                    -you can optionally supply a second argument which will be returned instead of None
                                                             
                                        ex:
                                        
                                                    art_galleries.get('Louvre','Not Found')                
                                           If you do supply a valid key to the get() method it will return the value from the dictionary 
                                            
         
         -WQorking with nested data
                    -Can also nest dictionaries to group data or establish hierarchy 
                                .keys() method shows the keys for a given dictionary
                                
                                
                                                  art_galleries.keys()
                                                  dict_keys(['10021','10013','10001','10011'])
                                                  
                                                  print(art_galleries['10027'])
                                                  art_galleries['10027']['Inner City Art Ga;;ery Inc']  ##Getting the phone number of one of the galleries by using the gallery name which us the nested dictionary's key aas a secondary key
                                                  
                     -Nesting dictionaries is a very commom way to deal with repeating data structures such as yearly data, grouped, or hierarchical data such as organization reporting structures
                     -You can access nested values by providing multiple indices to the dictionary or using the get mothod on AN INDEX
                     
                                          -Can be accessed using multiple indices or the .get() method on an index
                                                  
         
         
         >>>>>>>>>>>>>>>>>> Code snippet: Creatijg and looping through dictionaries
                                     # Create an empty dictionary: names
                            names = {}

                            # Loop over the girl names
                            for name, rank in female_baby_names_2012:
                                # Add each name to the names dictionary using rank as the key
                                names[rank] = name

                            # Sort the names list by rank in descending order and slice the first 10 items
                            for rank in sorted(names,reverse=True)[:10]:
                                # Print each item
                                print(names[rank])


          >>>>>>>>>>>>>Code Snippet: Safely Finding by Key
          As demonstrated in the video, if you attempt to access a key that isn't present in a dictionary, you'll get a KeyError. One option to handle this type of error is to use a try: except: block. You can learn more about error handling in Python Data Science Toolbox (Part 1), specifically in this video.

Python provides a faster, more versatile tool to help with this problem in the form of the .get() method. The .get() method allows you to supply the name of a key, and optionally, what you'd like to have returned if the key is not found.
                             
                             
                             # Safely print rank 7 from the names dictionary
                                print(names.get(7))

                                # Safely print the type of rank 100 from the names dictionary
                                print(type(names.get(100)))

                                # Safely print rank 105 from the names dictionary or 'Not Found'
                                print(names.get(105,'Not Found'))








                  >>>>>>>>>>>>>Code Snippet: Dealing with Nested Data 


                                          # Print a list of keys from the boy_names dictionary
                      print(boy_names.keys())

                      # Print a list of keys from the boy_names dictionary for the year 2013
                      print(boy_names[2013].keys())

                      # Loop over the dictionary
                      for year in boy_names:
                          # Safely print the year and the third ranked name or 'Unknown'
                          print(year, boy_names[year].get(3,'Unknown'))   

         
         
         
  ----------------------------------Altering Dictionaries___________________________________________________
Dictionaries are mutable, so we can alter them in  number of ways
Adding and Extending Dictionaries
            - Assignment to add a new key/value to a dictionary
                              -You can add data to a dictionary just by using a new key as an index and assigning it a value 
                              -Also possible to supply a dictionary, list of tuples or a set of keywords arguments to the update()  method to add values into a dictionary
                                                  - .update() method to updaTE A DICTIONARY FROM ANOTHER DICTIONARY OR TUPLES OR KEYWORDS
                                                  
                              
                              
                              print(galleries_10007)    ### Have zipcode want to add
                              art_galleries['10007'] = galleries_10007    ### Assign zipcode as the key and then the dictionary as the value
                              
                              galleries_11234 = [("A J ARTS LTD', '(718) 763-5473'), ('Doug Meyer Fine Art", '(718) 375-8006')]   #### Can also create a list of tuples and supply them to the update() method
                              art_galleries['11234'].update(galleries_11234)   ### Supplying them to a dictionary index of the ziupcode since I want this data to be neted underneath it
                              
                              print(art_galleries['11234'])   ###Print the zipcode to be sure they wered added
            
         
         -Often we'll want to narrow the data to only the data which is relevant to the problem at hand, so let's lear how to remove data

Popping and deleting from dictionaries         
               - del instruction deletes a key?value  - however its important to remember that del will throw a KeyError if the key tyou're trying to delete doesn't exist
               - .pop() method safely removes a key/value froma dictionary 
         
                            - del art_galleries['11234']     ###let's start by removing all the galleries from zipcode '11234'
                            
                            galleries_10310 = art_galleries.pop('10310')        ### Not sure if there are any galleries in zipcode 10310, so I'm going to pop that zip code from the dictionary and save it
                            
                            
        Adding and extending dictionaries
If you have a dictionary and you want to add data to it, you can simply create a new key and assign the data you desire to it. It's important to remember that if it's a nested dictionary, then all the keys in the data path must exist, and each key in the path must be assigned individually.

You can also use the .update() method to update a dictionary with keys and values from another dictionary, tuples or keyword arguments. 
         
         
         
         
         
         
         >>>>>>>>>>>>>>>>> Code Snippet: Adding and Extending Dictionaries
         # Assign the names_2011 dictionary as the value to the 2011 key of boy_names
boy_names[2011] = names_2011

# Update the 2012 key in the boy_names dictionary
boy_names[2012].update(((1,'Casey'),(2,'Aiden')))

# Loop over the boy_names dictionary 
for year in boy_names:
    # Loop over and sort the data for each year by descending rank
    for rank in sorted(boy_names[year], reverse=True)[:1]:
        # Check that you have a rank
        if not rank:
            print(year, 'No Data Available')
        # Safely print the year and the least popular name or 'Not Available'
        print(year, boy_names[year].get(rank))
        
        
        
        Popping and deleting from dictionaries
Often, you will want to remove keys and value from a dictionary. You can do so using the del Python instruction. It's important to remember that del will throw a KeyError if the key you are trying to delete does not exist. You can not use it with the .get() method to safely delete items; however, it can be used with try: catch:.

If you want to save that deleted data into another variable for further processing, the .pop() dictionary method will do just that. You can supply a default value for .pop() much like you did for .get() to safely deal with missing keys. It's also typical to use .pop() instead of del since it is a safe method.

Here, you'll remove 2011 and 2015

>>>>>>>>>>>>>>>>>>Code Snippet
# Remove 2011 and store it: female_names_2011
female_names_2011 = female_names.pop(2011)

# Safely remove 2015 with an empty dictionary as the default: female_names_2015
female_names_2015 = female_names.pop(2015,{})

# Delete 2012
del female_names[2012]

# Print female_names
print(female_names)



        
        
-----------------------------------------------------Pythonically Using Dictionaries________________________________
 Previously we looped through dictionary keyts then used the keys to get the values we desired
 
          -   .items() method returns an object we can iterate over  ---   Python provides an items() method which returns a dict_items pobject but we can iterate over it as a list of key/value tuples
          
 If we use the .items()  metho on the original art_galleries dictionary it returns a tuple of the gallery name and then the phone number
        
         for gallery, phone_num in art_galleries.items():
                print(gallery)
                print(phone_num)
                
                
  I can use tuple unpacking to go ahead and expand that into its two components in the loop      
  Finally, I print them so you can see the information. 
  
  Now a more pythonic method for checking if the data is present in a dictionary 
  
  Checking Dictionairies for Data
            - earlier we ued the .get() method to safely check for keys and we can use that to check to see if a key is in a dictionary
            -python provides the in operator (which is much more efficient and clear) -- returns a boolean (True or False) 
                                                    -since returns a boolean, it is often used in conditionals statements like an if/else statement
  
  
                          '11234' in art_galleries        #Checks to see if key '11234' is in galleries
                          
                          
                          if '10010' in art_galleries : 
                                  print('I found: %s' % art_galleries['10010'])
                          else:
                                  print('No galleries found')
                          
     Working with dictionaries more pythonically
So far, you've worked a lot with the keys of a dictionary to access data, but in Python, the prefered manner for iterating over items in a dictionary is with the .items() method.

This returns each key and value from the dictionary as a tuple, which you can unpack in a for loop. You'll now get practice doing this.                     
         
 >>>>>>>>>>>Code Snippet: Working withj dictionaries more pythonically
 # Iterate over the 2014 nested dictionary
for rank, name in baby_names[2014].items():
    # Print rank and name
    print(rank, name)
    
# Iterate over the 2012 nested dictionary
for rank, name in baby_names[2012].items():
    print(rank, name)
    # Print rank and name
  
         
         
         
         
Checking dictionaries for data

You can check to see if a key exists in a dictionary by using the in expression.

For example, you can check to see if 'cookies' is a key in the dictionary by using if 'cookies' in recipes_dict: this allows you to safely react to data being present in the dictionary.

You can also use the in expression so see if data is in the value of a dictionary such as if 'cookies' in recipes_dict.values(). Remember you have to handle nested dictionaries differently as illustrated in the video and previous exercises, and use the in expression on each nested dictionary.         
         
         >>>>>>>>>>> Code Snippet
         # Check to see if 2011 is in baby_names
if '2011' in baby_names:
    # Print 'Found 2011'
    print('Found 2011')
    
# Check to see if rank 1 is in 2012
if 1 in baby_names[2012]:
    # Print 'Found Rank 1 in 2012' if found
    print('Found Rank 1 in 2012')
else:
    # Print 'Rank 1 missing from 2012' if not found
    print('Rank 1 missing from 2012')
    
# Check to see if Rank 5 is in 2013
if 5 in baby_names[2013]:
   # Print 'Found Rank 5'
   print('Found Rank 5')
   
   
------------------------------------------Working with CSV Files------------------------------------
Reading from a file using CSV reader

-Python csv module 
             - open() function provides a variable that represents a file, takes a path and a mode - 
                -To create a Python file object, you use the open() function, which accepts a name and a mode
                 - The mode is typically 'r' for read and 'w' for write
                 
              - then we pass the file object to the .reader() metho on the csv module and use it as you would any other iterable
                     csv.reader() reads a file object and returns the lines from the file as tuples
                     .close() method closes file objects
                     
              
              import csv                                      #import the csv module
              csvfile = open('ART_GALLERY.csv','r')              # create a fiule objects for the ART_GALLERY.csv data fiule
              for row in csv.reader(csvfile):                     # Then I use the csv.reader to read the file and iterate over each line or row in the file and print it
              
                      print(row)
              
                     
                     
   -python csv module also provides a way to directly create a dictionary from a csv file with the Dct Reader class
                  - often we want to go from csv file to dictionary
                  - DictReader does just that
                                        -if the file has a header row, that row will automaticcally be used as the keys for the dictionary
                  - If data doesn't have a header row, you can pass in the column names
                  - Eeach row of the file is returned as an OrderedDict object 
                  
                  -It's all the same until the line where we use the DictReader instead of the reaer method
                  -Then we print the row, we get an OrderedDict that looks like a list of tuples; however, it operates just like a normal dictionary
                  
                  
                      import csv
                      csvfile = open('ART_GALLERY.csv','r')
                      
                      for row in csv.DictReader(csvfile):
                              print(row)
   
                       csvfile.close()
       
       
       
 >>>>>>>>>>>>>> Code Snippet: Reading from a file using CSV reader
 Python provides a wonderful module called csv to work with CSV files. You can pass the .reader() method of csv a Python file object and use it as you would any other iterable. To create a Python file object, you use the open() function, which accepts a file name and a mode. The mode is typically 'r' for read or 'w' for write.

Though you won't use it for this exercise, often CSV files will have a header row with field names, and you will need to use slice notation such as [1:] to skip the header row
       
       # Import the python CSV module
import csv

# Create a python file object in read mode for the baby_names.csv file: csvfile
csvfile = open('baby_names.csv','r')

# Loop over a csv reader on the file object
for row in csv.reader(csvfile):
    # Print each row 
    print(row)
    # Add the rank and name to the dictionary
    baby_names[row[5]] = row[3]

# Print the dictionary keys
print(baby_names.keys())


>>>>>>>>>>>>>>> Code Snippet: Creating a dictionary from a file
The csv module also provides a way to directly create a dictionary from a CSV file with the DictReader class. If the file has a header row, that row will automatically be used as the keys for the dictionary. However, if not, you can supply a list of keys to be used. Each row from the file is returned as a dictionary. Using DictReader can make it much easier to read your code and understand what data is being used, especially when compared to the numbered indexes you used in the prior exercise.
# Import the python CSV module
import csv

# Create a python file object in read mode for the `baby_names.csv` file: csvfile
csvfile = open('baby_names.csv','r')

# Loop over a DictReader on the file
for row in csv.DictReader(csvfile):
    # Print each row 
    print(row)
    # Add the rank and name to the dictionary: baby_names
    baby_names[row['RANK']] = row['NAME']

# Print the dictionary keys
print(baby_names.keys())




------------------------------------- Counting Made Easy ________________________________
As data scientist, going to need to count items, create dictionary values before we know the keys to store them in, or maintain order in a dictionary 

Collections Module
    -Part of standard library
    -Advanced data containers
    
    
Counter - powerful python object based on the dictionary object that accepts a list and counts the number of times a values is found within the elements of that list
                -Special dictionary used for counting data, measruing frequency
                
                
                -Since it's dictionary based, can use all the normal dictionary features 
                

                        from collections import Counter
                        
                        nyc_eatery_count_by_types = Counter(nyc_eatery_types)   ### Here have a list named nyc_eatery_types that contains one column of data called type from a table about eateries in NYC parks
                                                                                 ### I create a new Conter based on that list and print it
                        print(nyc_eatery_count_by_type)          ### Can see each type from list ad the number of times it was found in the list
                         print(nyc_eatert_count_by_times['Restaurant'])                                        ### I can also see how many restaurants are in the counter by using Restaurant as the index and printing it
                                                                 

-Counters also provide a wonderful way to find the high values they contain
            -Counter t find the most common
                                  -  .most_common() method returns the counter values in descending order
                                              -returns a list of tuples containing the items and their count in descending order
                                  -great for frequency analytics,how often someting occurs            
                
                        print(nyc_eatery_count_by_types.most_common(3))  ###Here printing the top 3 eatery types in the NYC part system with the most_common method and passing t 3 as the numer of items to return
                                            

>>>>>>>>>>>>>>>>> Code Snippet: Using Counter on Lists
Counter is a powerful tool for counting, validating, and learning more about the elements within a dataset that is found in the collections module. You pass an iterable (list, set, tuple) or a dictionary to the Counter. You can also use the Counter object similarly to a dictionary with key/value assignment, for example counter[key] = value.

A common usage for Counter is checking data for consistency prior to using it, so let's do just that. In this exercise, you'll be using data from the Chicago Transit Authority on ridership.

       
       # Import the Counter object
from collections import Counter

# Print the first ten items from the stations list
print(stations[:10])

# Create a Counter of the stations list: station_count
station_count = Counter(stations)

# Print the station_count
print(station_count)




>>>>>>>>>>>>>>>>>>>>>>> Code Snippet: Finding the most common elements
Another powerful usage of Counter is finding the most common elements in a list. This can be done with the .most_common() method.

# Import the Counter object
from collections import Counter

# Create a Counter of the stations list: station_count
station_count = Counter(stations)

# Find the 5 most common elements
print(station_count.most_common(5))




--------------------------------------------------Dictionaries of unknown structures - Defaultdict _____________________________
Often will be working with data where we don't know all the keys that will be used but want to store a coplex structure under those keys

A good is example is I want every key to have a list of values
I' have to initialize every key with an empty list then asd the values to the list

Dictionary Handling - Ex (without Defaultdict)
      I can start by looping over a list of tuples with the park's d ad the name of the eatery
      
      for park_id, name in nyc_eateries_parks: 
              if park_id not in eateris_by_park:                   ### The can check to see if have a list for that aprt already in the dictionary
                      eateries_by_park[park_id] = []                ### If not then create an empty list
              eateries_by_park[park_id].append(name)                ### Next, append the name of the eatery to the list for that park id



Using defaultdict
            -Thankfully collections provides an easier way using defaultdict
                    -Pass it a default type tht every key will have even if it doesn't currently exist
                            -Defaultdict accepts a type that every value will default to if the key is not in present in the dictionary
                      - Works exactly like a dictionary
                               -You can overrude that type by setting the key manually to a value of a different type
                               
            -Still working with the nyc eatery, have a list of tuples that contain the park id and the name of an eatery 
            - I eant to create a list of eateries by park 
       
       
            from collections import defaultdict
            eateries_by_park = defaultdict(list)     ### Next, create a defaultdict that defaults to a list 
            
            for park_id, name in nyc_eateries_parks:          #### Next I iterae over my data and npack it into the park_id and name
               eateries_by_park[park_id].append(name)       #### I append each eatery name into list for each park_id
       
       
       It's also common to use a defaultdict as a type of counter for a list of dictionaries where we are counting ultiple keys from those dictionaries
                  In  our new york city eateries, curious as to how many had a published phone number or a website.
                  
                  
                  from collections import defaultdict
                  eatery_contact_types = defaultdict(int)   ### This time when creating my defaultdict, I tell it I ant it to be an int. 
                  
                  
                  for eatery in nyc_eateries:     
                      if eatery.get('phone'):
                              eatery_contact_types['phones'] += 1     #### Then I look over my nyc_eateries data and add 1 to the phones key if it has a phone number that is not None
                      if eatery.get('website'):
                               eatery_contact_types['websites'] += 1     #### Then I add one to the key if it has a websites
       
                  
                  
  >>>>>>>>>>>>>>> Code Snippet: Creating dictionaries of an unknown structure
  
  # Create an empty dictionary: ridership
ridership = {}

# Iterate over the entries
for date, stop, riders in entries:
    # Check to see if date is already in the dictionary
    if date not in ridership:
        # Create an empty list for any missing date
        ridership[date] = []
    # Append the stop and riders as a tuple to the date keys list
    ridership[date].append((stop,riders))

    
# Print the ridership for '03/09/2016'
print(ridership['03/09/2016'])




>>>>>>>>>>>>>>>> Code Snippet: Safely appending to a key's value list 
Safely appending to a key's value list
Often when working with dictionaries, you know the data type you want to have each key be; however, some data types such as lists have to be initialized on
each key before you can append to that list.

A defaultdict allows you to define what each uninitialized key will contain. When establishing a defaultdict, you pass it the type you want it to be, such as a list, tuple, set, int, string, dictionary or any other valid type object.


# Import defaultdict
from collections import defaultdict

# Create a defaultdict with a default type of list: ridership
ridership = defaultdict(list)

# Iterate over the entries
for date, stop, riders in entries:
    # Use the stop as the key of ridership and append the riders to its value
    ridership[stop].append(riders)
    
# Print the first 10 items of the ridership dictionary
print(list(ridership.items())[:10])




----------------------Maintaining Dictionary Order with OrderDict-----------------------------------
Often we want to store data in the dictionary in an ordered fashion 
For example, I might want to store the data in order by date, or by a ranking

Order in Python Dictionaries
      -Normal dictionaries don't maintain order of the keys hat you insert into them before Python 3.6
          Python version > 3.6 ordered
          
          
       However, the collections module provides an OrderedDict that maintains the order that keys and values as they were added to the dictionary without regard for the Python version
       You might remember this from our video usi g the CSV dictreader whch returned each row as an OrderedDict
       
       
Getting Started with OrderedDict
       
       
       
       from collections import OrderedDict
       
       nyc_eatery_permits = OrderedDict()   ### Next I create an OrderedDict to hold the NYC park data by permit end date
       
       for eatery in nyc_eateries:     ### Then I loop over the NYC park eateries which are ordered by permit end date already and add them to the OrderedDict by that date
              nyc_eatery_permits[eatert['end_date']] = eatery
       print(list(nyc_eatery_permits.items())[:3]      ###Finally I can print the first 3 permit end dates by making a list of the items and slicing it
       
       
 OrderedDict power feature
        .popitem() method returns items in reverse insertion order
        
                        print(nyc_eatery_permits.popitems())     ###using the OrderedDict from previous examples, I use popitem() and get the permit that expires the latest, a second popitem() retrns the next latest experiation
                        
         Finallt I can pop the lowest end date in the dictionary by using popitem(last=False) here               
       
       
       
      
      



  
  














