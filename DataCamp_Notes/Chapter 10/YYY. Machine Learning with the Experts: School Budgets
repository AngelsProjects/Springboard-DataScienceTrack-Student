Course Description


Data science isn't just for predicting ad-clicks-it's also useful for social impact! This course is a case study from a machine learning competition on DrivenData. You'll explore a problem related to school district budgeting. By building a model to automatically classify items in a school's budget, it makes it easier and faster for schools to compare their spending with other schools. In this course, you'll begin by building a baseline model that is a simple, first-pass approach. In particular, you'll do some natural language processing to prepare the budgets for modeling. Next, you'll have the opportunity to try your own techniques and see how they compare to participants from the competition. Finally, you'll see how the winner was able to combine a number of expert techniques to build the most accurate model.



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

1
Exploring the raw data
FREE
0%
In this chapter, you'll be introduced to the problem you'll be solving in this course. How do you accurately classify line-items in a school budget based on what that money is being used for? You will explore the raw text and numeric values in the dataset, both quantitatively and visually. And you'll learn how to measure success when trying to predict class labels for each row of the dataset.

-------------------------------------------------------------------------------------------------------------------------------------

Introducing the challenge
● Learn from the expert who won DrivenData’s challenge
● Natural language processing
● Feature engineering
● Efficiency boosting hashing tricks
● Use data to have a social impact



Introducing the challenge
● Budgets for schools are huge, complex, and not standardized
● Hundreds of hours each year are spent manually labelling
● Goal: Build a machine learning algorithm that can automate
the process
● Budget data
● Line-item: “Algebra books for 8th grade students”
● Labels: “Textbooks”, “Math”, “Middle School”
● This is a supervised learning problem



Over 100 target variables!
● Pre_K:
● NO_LABEL
● Non PreK
● PreK
● Reporting:
● NO_LABEL
● Non-School
● School
● Sharing:
● Leadership &
Management
● NO_LABEL
● School Reported
● Student_Type:
● Alternative
● At Risk
● … 



How we can help
● Predictions will be probabilities for each label



-------------------------------------------------------------------------------------------------------------------------------------


Exploring the data


A column for each possible value


Load and preview the data
In [1]: import pandas as pd
In [2]: sample_df = pd.read_csv('sample_data.csv')
In [3]: sample_df.head()
Out[3]:
 label numeric text with_missing
0 a -4.167578 bar -4.084883
1 a -0.562668 2.043464
2 a -21.361961 -33.315334
3 b 16.402708 foo bar 30.884604
4 a -17.934356 foo -27.488405




Summarize the data
In [4]: sample_df.info()
<class 'pandas.core.frame.DataFrame'>
Int64Index: 100 entries, 0 to 99
Data columns (total 4 columns):
label 100 non-null object
numeric 100 non-null float64
text 100 non-null object
with_missing 95 non-null float64
dtypes: float64(2), object(2)
memory usage: 3.9+ KB 



Summarize the data
In [5]: sample_df.describe()
Out[5]:
 numeric with_missing
count 100.000000 95.000000
mean -1.037411 1.275189
std 10.422602 17.386723
min -26.594495 -42.210641
25% -6.952244 -8.312870
50% -0.653688 1.733997
75% 5.398819 11.777888
max 22.922080 41.967536 
-------------------------------------------------------------------------------------------------------------------------------------

Loading the data
Now it's time to check out the dataset! You'll use pandas (which has been pre-imported as pd) to load your data into a DataFrame and then do some Exploratory Data Analysis (EDA) of it.

The training data is available as TrainingData.csv. Your first task is to load it into a DataFrame in the IPython Shell using pd.read_csv() along with the keyword argument index_col=0.

Use methods such as .info(), .head(), and .tail() to explore the budget data and the properties of the features and labels.

Some of the column names correspond to features - descriptions of the budget items - such as the Job_Title_Description column. The values in this column tell us if a budget item is for a teacher, custodian, or other employee.

Some columns correspond to the budget item labels you will be trying to predict with your model. For example, the Object_Type column describes whether the budget item is related classroom supplies, salary, travel expenses, etc.

Use df.info() in the IPython Shell to answer the following questions:

How many rows are there in the training data?
How many columns are there in the training data?
How many non-null entries are in the Job_Title_Description column?

-------------------------------------------------------------------------------------------------------------------------------------


Summarizing the data
You'll continue your EDA in this exercise by computing summary statistics for the numeric data in the dataset. The data has been pre-loaded into a DataFrame called df.

You can use df.info() in the IPython Shell to determine which columns of the data are numeric, specifically type float64. You'll notice that there are two numeric columns, called FTE and Total.

FTE: Stands for "full-time equivalent". If the budget item is associated to an employee, this number tells us the percentage of full-time that the employee works. A value of 1 means the associated employee works for the school full-time. A value close to 0 means the item is associated to a part-time or contracted employee.
Total: Stands for the total cost of the expenditure. This number tells us how much the budget item cost.
After printing summary statistics for the numeric data, your job is to plot a histogram of the non-null FTE column to see the distribution of part-time and full-time employees in the dataset.

Instructions
100 XP
Print summary statistics of the numeric columns in the DataFrame df using the .describe() method.
Import matplotlib.pyplot as plt.
Create a histogram of the non-null 'FTE' column. You can do this by passing df['FTE'].dropna() to plt.hist().
The title has been specified and axes have been labeled, so hit 'Submit Answer' to see how often school employees work full-time!

# Print the summary statistics
print(df.describe())

# Import matplotlib.pyplot as plt
import matplotlib.pyplot as plt

# Create the histogram
plt.hist(df['FTE'].dropna())

# Add title and labels
plt.title('Distribution of %full-time \n employee works')
plt.xlabel('% of full-time')
plt.ylabel('num employees')

# Display the histogram
plt.show()
-------------------------------------------------------------------------------------------------------------------------------------


Looking
at the
datatypes



Objects instead of categories
In [1]: sample_df['label'].head()
Out[1]:
0 a
1 a
2 a
3 b
4 a
Name: label, dtype: object 



 ML algorithms work on numbers, not strings
● Need a numeric representation of these strings
● Strings can be slow compared to numbers
● In pandas, ‘category’ dtype encodes categorical data
numerically
● Can speed up code



Encode labels as categories (sample data)
In [1]: sample_df.label.head(2)
Out[1]:
0 a
1 b
Name: label, dtype: object
In [2]: sample_df.label = sample_df.label.astype('category')
In [3]: sample_df.label.head(2)
Out[3]:
0 a
1 b
Name: label, dtype: category
Categories (2, object): [a, b]



Dummy variable encoding
In [4]: dummies = pd.get_dummies(sample_df[['label']], prefix_sep='_')
In [5]: dummies.head(2)
Out[5]:
 label_a label_b
0 1 0
1 0 1
● Also called a ‘binary indicator’ representation 


Lambda functions
In [6]: square = lambda x: x*x
In [6]: square(2)
Out[6]: 4


Encode labels as categories
● In the sample dataframe, we only have one relevant column
● In the budget data, there are multiple columns that need to be
made categorical 


Encode labels as categories
In [7]: categorize_label = lambda x: x.astype('category')
In [8]: sample_df.label = sample_df[['label']].apply(categorize_label,
 ...: axis=0)
In [9]: sample_df.info()
<class 'pandas.core.frame.DataFrame'>
Int64Index: 100 entries, 0 to 99
Data columns (total 4 columns):
label 100 non-null category
numeric 100 non-null float64
text 100 non-null object
with_missing 95 non-null float64
dtypes: category(1), float64(2), object(1)
memory usage: 3.2+ KB

-------------------------------------------------------------------------------------------------------------------------------------

Encode the labels as categorical variables
Remember, your ultimate goal is to predict the probability that a certain label is attached to a budget line item. You just saw that many columns in your data are the inefficient object type. Does this include the labels you're trying to predict? Let's find out!

There are 9 columns of labels in the dataset. Each of these columns is a category that has many possible values it can take. The 9 labels have been loaded into a list called LABELS. In the Shell, check out the type for these labels using df[LABELS].dtypes.

You will notice that every label is encoded as an object datatype. Because category datatypes are much more efficient your task is to convert the labels to category types using the .astype() method.

Note: .astype() only works on a pandas Series. Since you are working with a pandas DataFrame, you'll need to use the .apply() method and provide a lambda function called categorize_label that applies .astype() to each column, x.

Instructions
100 XP
Define the lambda function categorize_label to convert column x into x.astype('category').
Use the LABELS list provided to convert the subset of data df[LABELS] to categorical types using the .apply() method and categorize_label. Don't forget axis=0.
Print the converted .dtypes attribute of df[LABELS].
Take Hint (-30 XP)


# Define the lambda function: categorize_label
categorize_label = lambda x: x.astype('category')

# Convert df[LABELS] to a categorical type
df[LABELS] = df[LABELS].apply(categorize_label, axis=0)

# Print the converted dtypes
print(df[LABELS].dtypes)

<script.py> output:
    Function            category
    Use                 category
    Sharing             category
    Reporting           category
    Student_Type        category
    Position_Type       category
    Object_Type         category
    Pre_K               category
    Operating_Status    category
    dtype: object


-------------------------------------------------------------------------------------------------------------------------------------
Counting unique labels
As Peter mentioned in the video, there are over 100 unique labels. In this exercise, you will explore this fact by counting and plotting the number of unique values for each category of label.

The dataframe df and the LABELS list have been loaded into the workspace; the LABELS columns of df have been converted to category types.

pandas, which has been pre-imported as pd, provides a pd.Series.nunique method for counting the number of unique values in a Series.

Instructions
100 XP
Create the DataFrame num_unique_labels by using the .apply() method on df[LABELS] with pd.Series.nunique as the argument.
Create a bar plot of num_unique_labels using pandas' .plot(kind='bar') method.
The axes have been labeled for you, so hit 'Submit Answer' to see the number of unique values for each label.


# Import matplotlib.pyplot
import matplotlib.pyplot as plt

# Calculate number of unique values for each label: num_unique_labels
num_unique_labels = df[LABELS].apply(pd.Series.nunique)

# Plot number of unique values for each label
num_unique_labels.plot(kind='bar')

# Label the axes
plt.xlabel('Labels')
plt.ylabel('Number of unique values')

# Display the plot
plt.show()




-------------------------------------------------------------------------------------------------------------------------------------

How do
we
measure
success?

● Accuracy can be misleading when classes are imbalanced
● Legitimate email: 99%, Spam: 1%
● Model that never predicts spam will be 99% accurate!
● Metric used in this problem: log loss
● It is a loss function
● Measure of error
● Want to minimize the error (unlike accuracy)



Log loss binary classification
● Log loss for binary classification
● Actual value: y = {1=yes, 0=no}
● Prediction (probability that the value is 1): p


Log loss binary classification: example
logloss(N=1) = y log(p) + (1 − y) log(1 − p)
● True label = 0
● Model confidently predicts 1 (with p = 0.90)
● Log loss =
● = log(1 - 0.9)
● = log(0.1)
● = 2.30

Log loss binary classification: example
logloss(N=1) = y log(p) + (1 − y) log(1 − p)
True label = 1
● Model predicts 0 (with p = 0.50)
● Log loss = 0.69
● Be"er to be less confident than confident and wrong


Computing log loss with NumPy
import numpy as np
def compute_log_loss(predicted, actual, eps=1e-14):
 """ Computes the logarithmic loss between predicted and
 actual when these are 1D arrays.

 :param predicted: The predicted probabilities as floats between 0-1
 :param actual: The actual binary labels. Either 0 or 1.
 :param eps (optional): log(0) is inf, so we need to offset our
 predicted values slightly by eps from 0 or 1.
 """
 predicted = np.clip(predicted, eps, 1 - eps)
 loss = -1 * np.mean(actual * np.log(predicted)
 + (1 - actual)
 * np.log(1 - predicted))

 return loss


Computing log loss with NumPy
In [1]: compute_log_loss(predicted=0.9, actual=0)
Out[1]: 2.3025850929940459
In [2]: compute_log_loss(predicted=0.5, actual=1)
Out[2]: 0.69314718055994529
-------------------------------------------------------------------------------------------------------------------------------------

Computing log loss with NumPy
To see how the log loss metric handles the trade-off between accuracy and confidence, we will use some sample data generated with NumPy and compute the log loss using the provided function compute_log_loss(), which Peter showed you in the video.

5 one-dimensional numeric arrays simulating different types of predictions have been pre-loaded: actual_labels, correct_confident, correct_not_confident, wrong_not_confident, and wrong_confident.

Your job is to compute the log loss for each sample set provided using the compute_log_loss(predicted_values, actual_values). It takes the predicted values as the first argument and the actual values as the second argument.

Instructions
100 XP
Using the compute_log_loss() function, compute the log loss for the following predicted values (in each case, the actual values are contained in actual_labels):
correct_confident.
correct_not_confident.
wrong_not_confident.
wrong_confident.
actual_labels.


# Compute and print log loss for 1st case
correct_confident = compute_log_loss(correct_confident, actual_labels)
print("Log loss, correct and confident: {}".format(correct_confident)) 

# Compute log loss for 2nd case
correct_not_confident = compute_log_loss(correct_not_confident, actual_labels)
print("Log loss, correct and not confident: {}".format(correct_not_confident)) 

# Compute and print log loss for 3rd case
wrong_not_confident = compute_log_loss(wrong_not_confident, actual_labels)
print("Log loss, wrong and not confident: {}".format(wrong_not_confident)) 

# Compute and print log loss for 4th case
wrong_confident = compute_log_loss(wrong_confident,actual_labels)
print("Log loss, wrong and confident: {}".format(wrong_confident)) 

# Compute and print log loss for actual labels
actual_labels = compute_log_loss(actual_labels, actual_labels)
print("Log loss, actual labels: {}".format(actual_labels)) 

<script.py> output:
    Log loss, correct and confident: 0.05129329438755058
    Log loss, correct and not confident: 0.4307829160924542
    Log loss, wrong and not confident: 1.049822124498678
    Log loss, wrong and confident: 2.9957322735539904
    Log loss, actual labels: 9.99200722162646e-15


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


2
Creating a simple first model
0%
In this chapter, you'll build a first-pass model. You'll use numeric data only to train the model. Spoiler alert - throwing out all of the text data is bad for performance! But you'll learn how to format your predictions. Then, you'll be introduced to natural language processing (NLP) in order to start working with the large amounts of text in the data.

-------------------------------------------------------------------------------------------------------------------------------------
It's time to build a model
● Always a good approach to start with a very simple model
● Gives a sense of how challenging the problem is
● Many more things can go wrong in complex models
● How much signal can we pull out using basic methods?




It's time to build a model
● Train basic model on numeric data only
● Want to go from raw data to predictions quickly
● Multi-class logistic regression
● Train classifier on each label separately and
use those to predict
● Format predictions and save to csv
● Compute log loss score




Spli!ing the multi-class dataset
● Recall: Train-test split
● Will not work here
● May end up with labels in test set that never
appear in training set
● Solution: StratifiedShuffleSplit
● Only works with a single target variable
● We have many target variables
● multilabel_train_test_split()




Spli!ing the data
In [1]: data_to_train = df[NUMERIC_COLUMNS].fillna(-1000)
In [2]: labels_to_use = pd.get_dummies(df[LABELS])
In [3]: X_train, X_test, y_train, y_test = multilabel_train_test_split(
 data_to_train, labels_to_use,
 size=0.2, seed=123




Training the model
In [4]: from sklearn.linear_model import LogisticRegression
In [5]: from sklearn.multiclass import OneVsRestClassifier
In [6]: clf = OneVsRestClassifier(LogisticRegression())
In [7]: clf.fit(X_train, y_train)

● OneVsRestClassifier:
● Treats each column of y independently
● Fits a separate classifier for each of the columns
-------------------------------------------------------------------------------------------------------------------------------------

Setting up a train-test split in scikit-learn
Alright, you've been patient and awesome. It's finally time to start training models!

The first step is to split the data into a training set and a test set. Some labels don't occur very often, but we want to make sure that they appear in both the training and the test sets. We provide a function that will make sure at least min_count examples of each label appear in each split: multilabel_train_test_split.

Feel free to check out the full code for multilabel_train_test_split here.

You'll start with a simple model that uses just the numeric columns of your DataFrame when calling multilabel_train_test_split. The data has been read into a DataFrame df and a list consisting of just the numeric columns is available as NUMERIC_COLUMNS.

Instructions
100 XP
Create a new DataFrame named numeric_data_only by applying the .fillna(-1000) method to the numeric columns (available in the list NUMERIC_COLUMNS) of df.
Convert the labels (available in the list LABELS) to dummy variables. Save the result as label_dummies.
In the call to multilabel_train_test_split(), set the size of your test set to be 0.2. Use a seed of 123.
Fill in the .info() method calls for X_train, X_test, y_train, and y_test.


# Create the new DataFrame: numeric_data_only
numeric_data_only = df[NUMERIC_COLUMNS].fillna(-1000)

# Get labels and convert to dummy variables: label_dummies
label_dummies = pd.get_dummies(df[LABELS])

# Create training and test sets
X_train, X_test, y_train, y_test = multilabel_train_test_split(numeric_data_only,
                                                               label_dummies,
                                                               size=0.2, 
                                                               seed=123)

# Print the info
print("X_train info:")
print(X_train.info())
print("\nX_test info:")  
print(X_test.info())
print("\ny_train info:")  
print(y_train.info())
print("\ny_test info:")  
print(y_test.info()) 


<script.py> output:
    X_train info:
    <class 'pandas.core.frame.DataFrame'>
    Int64Index: 1040 entries, 198 to 101861
    Data columns (total 2 columns):
    FTE      1040 non-null float64
    Total    1040 non-null float64
    dtypes: float64(2)
    memory usage: 24.4 KB
    None
    
    X_test info:
    <class 'pandas.core.frame.DataFrame'>
    Int64Index: 520 entries, 209 to 448628
    Data columns (total 2 columns):
    FTE      520 non-null float64
    Total    520 non-null float64
    dtypes: float64(2)
    memory usage: 12.2 KB
    None
    
    y_train info:
    <class 'pandas.core.frame.DataFrame'>
    Int64Index: 1040 entries, 198 to 101861
    Columns: 104 entries, Function_Aides Compensation to Operating_Status_PreK-12 Operating
    dtypes: float64(104)
    memory usage: 853.1 KB
    None
    
    y_test info:
    <class 'pandas.core.frame.DataFrame'>
    Int64Index: 520 entries, 209 to 448628
    Columns: 104 entries, Function_Aides Compensation to Operating_Status_PreK-12 Operating
    dtypes: float64(104)
    memory usage: 426.6 KB
    None

-------------------------------------------------------------------------------------------------------------------------------------

Training a model
With split data in hand, you're only a few lines away from training a model.

In this exercise, you will import the logistic regression and one versus rest classifiers in order to fit a multi-class logistic regression model to the NUMERIC_COLUMNS of your feature data.

Then you'll test and print the accuracy with the .score() method to see the results of training.

Before you train! Remember, we're ultimately going to be using logloss to score our model, so don't worry too much about the accuracy here. Keep in mind that you're throwing away all of the text data in the dataset - that's by far most of the data! So don't get your hopes up for a killer performance just yet. We're just interested in getting things up and running at the moment.

All data necessary to call multilabel_train_test_split() has been loaded into the workspace.

Instructions
100 XP
Import LogisticRegression from sklearn.linear_model and OneVsRestClassifier from sklearn.multiclass.
Instantiate the classifier clf by placing LogisticRegression() inside OneVsRestClassifier().
Fit the classifier to the training data X_train and y_train.
Compute and print the accuracy of the classifier using its .score() method, which accepts two arguments: X_test and y_test.

# Import classifiers
from sklearn.linear_model import LogisticRegression
from sklearn.multiclass import OneVsRestClassifier

# Create the DataFrame: numeric_data_only
numeric_data_only = df[NUMERIC_COLUMNS].fillna(-1000)

# Get labels and convert to dummy variables: label_dummies
label_dummies = pd.get_dummies(df[LABELS])

# Create training and test sets
X_train, X_test, y_train, y_test = multilabel_train_test_split(numeric_data_only,
                                                               label_dummies,
                                                               size=0.2, 
                                                               seed=123)

# Instantiate the classifier: clf
clf = OneVsRestClassifier(LogisticRegression())

# Fit the classifier to the training data
clf.fit(X_train, y_train)

# Print the accuracy
print("Accuracy: {}".format(clf.score(X_test, y_test)))

<script.py> output:
    Accuracy: 0.0
    
Ok! The good news is that your workflow didn't cause any errors. The bad news is that your model scored the lowest possible accuracy: 0.0! But hey, you just threw away ALL of the text data in the budget. Later, you won't. Before you add the text data, let's see how the model does when scored by log loss.    
    

-------------------------------------------------------------------------------------------------------------------------------------

Making
predictions


Predicting on holdout data
In [1]: holdout = pd.read_csv('HoldoutData.csv', index_col=0)
In [2]: holdout = holdout[NUMERIC_COLUMNS].fillna(-1000)
In [3]: predictions = clf.predict_proba(holdout)

● If .predict() was used instead:
● Output would be 0 or 1
● Log loss penalizes being confident and wrong
● Worse performance compared
to .predict_proba()



Submi!ing your predictions as a csv
● All forma"ing can be done with the pandas to_csv
function


Format and submit predictions
In [4]: prediction_df = pd.DataFrame(columns=pd.get_dummies(df[LABELS],
 ...: prefix_sep='__').columns,
 ...: index=holdout.index,
 ...: data=predictions)
In [5]: prediction_df.to_csv('predictions.csv')
In [6]: score = score_submission(pred_path='predictions.csv')


DrivenData leaderboard

-------------------------------------------------------------------------------------------------------------------------------------

Use your model to predict values on holdout data
You're ready to make some predictions! Remember, the train-test-split you've carried out so far is for model development. The original competition provides an additional test set, for which you'll never actually see the correct labels. This is called the "holdout data."

The point of the holdout data is to provide a fair test for machine learning competitions. If the labels aren't known by anyone but DataCamp, DrivenData, or whoever is hosting the competition, you can be sure that no one submits a mere copy of labels to artificially pump up the performance on their model.

Remember that the original goal is to predict the probability of each label. In this exercise you'll do just that by using the .predict_proba() method on your trained model.

First, however, you'll need to load the holdout data, which is available in the workspace as the file HoldoutData.csv.

Instructions
100 XP
Read HoldoutData.csv into a DataFrame called holdout. Specify the keyword argument index_col=0 in your call to read_csv().
Generate predictions using .predict_proba() on the numeric columns (available in the NUMERIC_COLUMNS list) of holdout. Make sure to fill in missing values with -1000!
Take Hint (-30 XP)

# Instantiate the classifier: clf
clf = OneVsRestClassifier(LogisticRegression())

# Fit it to the training data
clf.fit(X_train, y_train)

# Load the holdout data: holdout
holdout = pd.read_csv('HoldoutData.csv',index_col=0)

# Generate predictions: predictions
predictions = clf.predict_proba(holdout[NUMERIC_COLUMNS].fillna(-1000))

-------------------------------------------------------------------------------------------------------------------------------------

Writing out your results to a csv for submission
At last, you're ready to submit some predictions for scoring. In this exercise, you'll write your predictions to a .csv using the .to_csv() method on a pandas DataFrame. Then you'll evaluate your performance according to the LogLoss metric discussed earlier!

You'll need to make sure your submission obeys the correct format.

To do this, you'll use your predictions values to create a new DataFrame, prediction_df.

Interpreting LogLoss & Beating the Benchmark:

When interpreting your log loss score, keep in mind that the score will change based on the number of samples tested. To get a sense of how this very basic model performs, compare your score to the DrivenData benchmark model performance: 2.0455, which merely submitted uniform probabilities for each class.

Remember, the lower the log loss the better. Is your model's log loss lower than 2.0455?

Instructions
100 XP
Create the prediction_df DataFrame by specifying the following arguments to the provided parameters pd.DataFrame():
pd.get_dummies(df[LABELS]).columns.
holdout.index.
predictions.
Save prediction_df to a csv file called 'predictions.csv' using the .to_csv() method.
Submit the predictions for scoring by using the score_submission() function with pred_path set to 'predictions.csv'.
Take Hint (-30 XP)

# Generate predictions: predictions
predictions = clf.predict_proba(holdout[NUMERIC_COLUMNS].fillna(-1000))

# Format predictions in DataFrame: prediction_df
prediction_df = pd.DataFrame(columns=pd.get_dummies(df[LABELS]).columns,
                             index=holdout.index,
                             data=predictions)


# Save prediction_df to csv
prediction_df.to_csv('predictions.csv')

# Submit the predictions for scoring: score
score = score_submission(pred_path='predictions.csv')

# Print score
print('Your model, trained with numeric data only, yields logloss score: {}'.format(score))


<script.py> output:
    Your model, trained with numeric data only, yields logloss score: 1.9067227623381413
    
    
    Incredible! Even though your basic model scored 0.0 accuracy, it nevertheless performs better than the benchmark score of 2.0455. You've now got the basics down and have made a first pass at this complicated supervised learning problem. It's time to step up your game and incorporate the text data.
-------------------------------------------------------------------------------------------------------------------------------------

A
very brief
introduction
to NLP


A very brief introduction to NLP
● Data for NLP:
     ● Text, documents, speech, …
● Tokenization
      ● Spli"ing a string into segments
      ● Store segments as list
● Example: ‘Natural Language Processing’
      ● —> [‘Natural’, ‘Language’, ‘Processing’]


Tokens and token pa!erns
● Tokenize on whitespace
      PETRO-VEND FUEL AND FLUIDS
      PETRO-VEND | FUEL | AND | FLUIDS
● Tokenize on whitespace and punctuation
      PETRO-VEND FUEL AND FLUIDS
      PETRO | VEND | FUEL | AND | FLUID
      
      
      
      
Bag of words representation
  ● Count the number of times a particular token appears
  ● “Bag of words”
    ● Count the number of times a word was
pulled out of the bag
● This approach discards information about word order
   ● “Red, not blue” is the same as “blue, not red”
   
   
   
-------------------------------------------------------------------------------------------------------------------------------------

Representing
text
numerically

Representing text numerically
● Bag-of-words
     ● Simple way to represent text in machine learning
     ● Discards information about grammar and word order
     ● Computes frequency of occurrence


Scikit-learn tools for bag-of-words
● CountVectorizer()
    ● Tokenizes all the strings
    ● Builds a ‘vocabulary’
    ● Counts the occurrences of each token in
    the vocabulary


Using CountVectorizer() on column of main dataset
   In [1]: from sklearn.feature_extraction.text import CountVectorizer
   In [2]: TOKENS_BASIC = '\\S+(?=\\s+)'
   In [3]: df.Program_Description.fillna('', inplace=True)
   In [4]: vec_basic = CountVectorizer(token_pattern=TOKENS_BASIC)
   
   
   
   
-------------------------------------------------------------------------------------------------------------------------------------
Using CountVectorizer() on column of main dataset

In [5]: vec_basic.fit(df.Program_Description)
Out[5]:
CountVectorizer(analyzer='word', binary=False, decode_error='strict',
 dtype=<class 'numpy.int64'>, encoding='utf-8', input='content',
 lowercase=True, max_df=1.0, max_features=None, min_df=1,
 ngram_range=(1, 1), preprocessor=None, stop_words=None,
 strip_accents=None, token_pattern='\\S+(?=\\s+)',
 tokenizer=None, vocabulary=None)
In [6]: msg = 'There are {} tokens in Program_Description if tokens are
any non-whitespace'
In [7]: print(msg.format(len(vec_basic.get_feature_names())))
There are 157 tokens in Program_Description if tokens are any nonwhitespace





-------------------------------------------------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------------------------------------------------


-------------------------------------------------------------------------------------------------------------------------------------



+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


3
Improving your model
0%
Here, you'll improve on your benchmark model using pipelines. Because the budget consists of both text and numeric data, you'll learn to how build pipielines that process multiple types of data. You'll also explore how the flexibility of the pipeline workflow makes testing different approaches efficient, even in complicated problems like this one!


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


4
Learning from the experts
0%
In this chapter, you will learn the tricks used by the competition winner, and implement them yourself using scikit-learn. Enjoy!
